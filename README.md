# Design Patterns With Typescript

[中文版](./README-CN.md)

Design patterns are general reusable solutions to common problems that occur in software design. They represent best practices evolved over time by experienced software developers. There are 23 well-known design patterns:

- Singleton Pattern:

Ensures a class has only one instance and provides a global point of access to it.

- Factory Method Pattern:

Defines an interface for creating an object but leaves the choice of its type to the subclasses, creating an instance of a class.

- Abstract Factory Pattern:

Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

- Builder Pattern:

Separates the construction of a complex object from its representation, allowing the same construction process to create various representations.

- Prototype Pattern:

Creates new objects by copying an existing object, known as the prototype.

- Adapter Pattern:

Allows the interface of an existing class to be used as another interface.

- Decorator Pattern:

Attaches additional responsibilities to an object dynamically.

- Proxy Pattern:

Provides a surrogate or placeholder for another object to control access to it.

- Observer Pattern:

Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

- Command Pattern:

Encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, queuing of requests, and logging of the parameters.

- Strategy Pattern:

Defines a family of algorithms, encapsulates each one, and makes them interchangeable.

- State Pattern:

Allows an object to alter its behavior when its internal state changes.

- Template Method Pattern:

Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

- Chain of Responsibility Pattern:

Passes the request along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.

- Interpreter Pattern:

Defines a grammar for the language the interpreter interprets.

- Memento Pattern:

Captures and externalizes an object's internal state so the object can be restored to this state later.

- Visitor Pattern:

Represents an operation to be performed on the elements of an object structure.

- Composite Pattern:

Composes objects into tree structures to represent part-whole hierarchies.

- Flyweight Pattern:

Minimizes memory usage or computational expenses by sharing as much as possible with related objects.

- Mediator Pattern:

Defines an object that centralizes communication between objects in a system.

- Command Pattern:

Encapsulates a request as an object, thereby allowing for parameterization of clients with different requests, queuing of requests, and logging of the parameters.

- Iterator Pattern:

Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

- Bridge Pattern:

Separates an object’s abstraction from its implementation so that the two can vary independently.
